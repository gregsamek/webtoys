<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clonecraft</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #blocker {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; align-items: center;
            justify-content: center; flex-direction: column; color: white;
            font-family: Arial, sans-serif; z-index: 100; cursor: pointer;
        }
        #blocker h1 { font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px #000; }
        #blocker p { font-size: 18px; margin: 5px 0; }
        #blocker .start-btn {
            margin-top: 30px; padding: 15px 40px; font-size: 24px;
            background: #4a4; border: none; color: white; cursor: pointer;
            border-radius: 5px;
        }
        #blocker .start-btn:hover { background: #5b5; }
        #blocker.hidden { display: none; }
        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 20px; height: 20px; z-index: 50; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: white;
            mix-blend-mode: difference;
        }
        #crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; left: 0; }
        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; z-index: 50; pointer-events: none;
        }
        .hotbar-slot {
            width: 50px; height: 50px; border: 3px solid #555;
            background: rgba(0,0,0,0.5); display: flex; align-items: center;
            justify-content: center;
        }
        .hotbar-slot.selected { border-color: white; }
        .block-preview { width: 36px; height: 36px; border-radius: 4px; }
        #debug {
            position: fixed; top: 10px; left: 10px; color: white;
            font-family: monospace; font-size: 14px; z-index: 50;
            text-shadow: 1px 1px 2px black; pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="blocker">
        <h1>⛏️ Clonecraft</h1>
        <p><b>WASD</b> - Move | <b>Space</b> - Jump | <b>Shift</b> - Sprint</p>
        <p><b>Mouse</b> - Look | <b>Left Click</b> - Break | <b>Right Click</b> - Place</p>
        <p><b>1-7</b> or <b>Scroll</b> - Select Block | <b>ESC</b> - Pause</p>
        <button class="start-btn" id="startBtn">Click to Play</button>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="debug"></div>

    <script>
        // === CANVAS & WEBGL SETUP ===
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
        const blocker = document.getElementById('blocker');
        const startBtn = document.getElementById('startBtn');
        const debugEl = document.getElementById('debug');
        const hotbarEl = document.getElementById('hotbar');

        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }

        // === CONFIGURATION ===
        const CHUNK_SIZE = 16;
        const WORLD_HEIGHT = 64;
        const RENDER_DISTANCE = 4;
        const GRAVITY = 28;
        const JUMP_FORCE = 10;
        const PLAYER_SPEED = 5;
        const SPRINT_SPEED = 8;
        const PLAYER_HEIGHT = 1.62;
        const PLAYER_WIDTH = 0.3;
        const EYE_HEIGHT = 1.5;

        // === BLOCK TYPES ===
        const BLOCKS = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, SAND: 6, WATER: 7
        };

        const BLOCK_NAMES = ['Air', 'Grass', 'Dirt', 'Stone', 'Wood', 'Leaves', 'Sand', 'Water'];

        const BLOCK_COLORS = {
            [BLOCKS.GRASS]: { top: [0.36, 0.7, 0.23], side: [0.55, 0.4, 0.26], bottom: [0.55, 0.4, 0.26] },
            [BLOCKS.DIRT]: { top: [0.55, 0.4, 0.26], side: [0.55, 0.4, 0.26], bottom: [0.55, 0.4, 0.26] },
            [BLOCKS.STONE]: { top: [0.5, 0.5, 0.52], side: [0.45, 0.45, 0.47], bottom: [0.4, 0.4, 0.42] },
            [BLOCKS.WOOD]: { top: [0.6, 0.5, 0.3], side: [0.5, 0.35, 0.2], bottom: [0.6, 0.5, 0.3] },
            [BLOCKS.LEAVES]: { top: [0.25, 0.55, 0.18], side: [0.22, 0.5, 0.15], bottom: [0.2, 0.45, 0.12] },
            [BLOCKS.SAND]: { top: [0.86, 0.82, 0.6], side: [0.82, 0.78, 0.56], bottom: [0.78, 0.74, 0.52] },
            [BLOCKS.WATER]: { top: [0.2, 0.4, 0.75], side: [0.18, 0.35, 0.7], bottom: [0.15, 0.3, 0.65] },
        };

        const HOTBAR_BLOCKS = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND, BLOCKS.WATER];

        // === MATH UTILITIES ===
        const vec3 = {
            create: () => new Float32Array(3),
            set: (o, x, y, z) => { o[0] = x; o[1] = y; o[2] = z; return o; },
            copy: (o, a) => { o[0] = a[0]; o[1] = a[1]; o[2] = a[2]; return o; },
            add: (o, a, b) => { o[0] = a[0] + b[0]; o[1] = a[1] + b[1]; o[2] = a[2] + b[2]; return o; },
            sub: (o, a, b) => { o[0] = a[0] - b[0]; o[1] = a[1] - b[1]; o[2] = a[2] - b[2]; return o; },
            scale: (o, a, s) => { o[0] = a[0] * s; o[1] = a[1] * s; o[2] = a[2] * s; return o; },
            cross: (o, a, b) => {
                const ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
                o[0] = ay * bz - az * by; o[1] = az * bx - ax * bz; o[2] = ax * by - ay * bx;
                return o;
            },
            normalize: (o, a) => {
                const len = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]) || 1;
                o[0] = a[0] / len; o[1] = a[1] / len; o[2] = a[2] / len;
                return o;
            },
            dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
            len: (a) => Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2])
        };

        const mat4 = {
            create: () => new Float32Array(16),
            identity: (o) => {
                o.fill(0); o[0] = o[5] = o[10] = o[15] = 1;
                return o;
            },
            perspective: (o, fov, aspect, near, far) => {
                const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
                o.fill(0);
                o[0] = f / aspect; o[5] = f; o[10] = (far + near) * nf;
                o[11] = -1; o[14] = 2 * far * near * nf;
                return o;
            },
            multiply: (o, a, b) => {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                      a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                      a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                      a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b0, b1, b2, b3;
                b0 = b[0]; b1 = b[1]; b2 = b[2]; b3 = b[3];
                o[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                o[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                o[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                o[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                o[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                o[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                o[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                o[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                o[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                o[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                o[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                o[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                o[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                o[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                o[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                o[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                return o;
            },
            lookAt: (o, eye, center, up) => {
                const z = vec3.create(), x = vec3.create(), y = vec3.create();
                vec3.sub(z, eye, center); vec3.normalize(z, z);
                vec3.cross(x, up, z); vec3.normalize(x, x);
                vec3.cross(y, z, x);
                o[0] = x[0]; o[1] = y[0]; o[2] = z[0]; o[3] = 0;
                o[4] = x[1]; o[5] = y[1]; o[6] = z[1]; o[7] = 0;
                o[8] = x[2]; o[9] = y[2]; o[10] = z[2]; o[11] = 0;
                o[12] = -vec3.dot(x, eye); o[13] = -vec3.dot(y, eye);
                o[14] = -vec3.dot(z, eye); o[15] = 1;
                return o;
            }
        };

        // === IMPROVED NOISE FUNCTION ===
        const Noise = (function() {
            const p = new Uint8Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];
            
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            return function(x, y, z = 0) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z;
                const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
                return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)),
                                       lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))),
                               lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)),
                                       lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));
            };
        })();

        function fbm(x, y, octaves = 4) {
            let val = 0, amp = 0.5, freq = 1;
            for (let i = 0; i < octaves; i++) {
                val += amp * Noise(x * freq, y * freq);
                amp *= 0.5;
                freq *= 2;
            }
            return val;
        }

        // === WEBGL SHADERS ===
        const vsSource = `
            attribute vec3 aPos;
            attribute vec3 aColor;
            attribute vec3 aNormal;
            uniform mat4 uMVP;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying float vDist;
            uniform vec3 uCamPos;
            void main() {
                gl_Position = uMVP * vec4(aPos, 1.0);
                vColor = aColor;
                vNormal = aNormal;
                vDist = length(aPos - uCamPos);
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying float vDist;
            uniform vec3 uFogColor;
            uniform float uFogNear;
            uniform float uFogFar;
            void main() {
                vec3 lightDir = normalize(vec3(0.4, 0.9, 0.3));
                float diff = max(dot(vNormal, lightDir), 0.0);
                float ambient = 0.5;
                vec3 color = vColor * (ambient + diff * 0.5);
                
                float fogFactor = clamp((uFogFar - vDist) / (uFogFar - uFogNear), 0.0, 1.0);
                color = mix(uFogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vsSource, fsSource) {
            const vs = createShader(gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const program = createProgram(vsSource, fsSource);

        const aPos = gl.getAttribLocation(program, 'aPos');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const aNormal = gl.getAttribLocation(program, 'aNormal');
        const uMVP = gl.getUniformLocation(program, 'uMVP');
        const uFogColor = gl.getUniformLocation(program, 'uFogColor');
        const uFogNear = gl.getUniformLocation(program, 'uFogNear');
        const uFogFar = gl.getUniformLocation(program, 'uFogFar');
        const uCamPos = gl.getUniformLocation(program, 'uCamPos');

        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        // === OUTLINE SHADER ===
        const outlineVsSource = `
            attribute vec3 aPos;
            uniform mat4 uMVP;
            void main() { gl_Position = uMVP * vec4(aPos, 1.0); }
        `;
        const outlineFsSource = `
            precision mediump float;
            void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); }
        `;
        const outlineProgram = createProgram(outlineVsSource, outlineFsSource);
        const outlineAPos = gl.getAttribLocation(outlineProgram, 'aPos');
        const outlineUMVP = gl.getUniformLocation(outlineProgram, 'uMVP');

        const outlineBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, outlineBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0,0,0, 1,0,0,  1,0,0, 1,0,1,  1,0,1, 0,0,1,  0,0,1, 0,0,0,
            0,1,0, 1,1,0,  1,1,0, 1,1,1,  1,1,1, 0,1,1,  0,1,1, 0,1,0,
            0,0,0, 0,1,0,  1,0,0, 1,1,0,  1,0,1, 1,1,1,  0,0,1, 0,1,1
        ]), gl.STATIC_DRAW);

        // === WORLD DATA ===
        const chunks = new Map();
        const chunkMeshes = new Map();

        function getChunkKey(cx, cz) { return `${cx},${cz}`; }

        function getBlock(x, y, z) {
            if (y < 0 || y >= WORLD_HEIGHT) return BLOCKS.AIR;
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunk = chunks.get(getChunkKey(cx, cz));
            if (!chunk) return BLOCKS.AIR;
            const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            return chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
        }

        function setBlock(x, y, z, type) {
            if (y < 0 || y >= WORLD_HEIGHT) return;
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const key = getChunkKey(cx, cz);
            let chunk = chunks.get(key);
            if (!chunk) return;
            
            const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
            
            rebuildChunk(cx, cz);
            if (lx === 0) rebuildChunk(cx - 1, cz);
            if (lx === CHUNK_SIZE - 1) rebuildChunk(cx + 1, cz);
            if (lz === 0) rebuildChunk(cx, cz - 1);
            if (lz === CHUNK_SIZE - 1) rebuildChunk(cx, cz + 1);
        }

        function generateChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (chunks.has(key)) return;
            
            const chunk = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * WORLD_HEIGHT);
            const trees = [];
            
            for (let lx = 0; lx < CHUNK_SIZE; lx++) {
                for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                    const wx = cx * CHUNK_SIZE + lx;
                    const wz = cz * CHUNK_SIZE + lz;
                    
                    const n = fbm(wx * 0.01, wz * 0.01, 4);
                    const height = Math.floor(25 + n * 25);
                    
                    for (let y = 0; y < WORLD_HEIGHT; y++) {
                        const idx = lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE;
                        if (y === 0) {
                            chunk[idx] = BLOCKS.STONE;
                        } else if (y < height - 4) {
                            chunk[idx] = BLOCKS.STONE;
                        } else if (y < height) {
                            chunk[idx] = BLOCKS.DIRT;
                        } else if (y === height) {
                            chunk[idx] = height <= 26 ? BLOCKS.SAND : BLOCKS.GRASS;
                        } else if (y <= 25) {
                            chunk[idx] = BLOCKS.WATER;
                        } else {
                            chunk[idx] = BLOCKS.AIR;
                        }
                    }
                    
                    // Mark tree positions
                    const treeNoise = Noise(wx * 0.5, wz * 0.5);
                    if (height > 27 && treeNoise > 0.4 && lx > 2 && lx < CHUNK_SIZE - 3 && lz > 2 && lz < CHUNK_SIZE - 3) {
                        trees.push({ lx, lz, height });
                    }
                }
            }
            
            // Generate trees
            for (const tree of trees) {
                const { lx, lz, height } = tree;
                const treeHeight = 5 + Math.floor(Noise(lx * 100, lz * 100) * 2);
                
                // Trunk
                for (let ty = 1; ty <= treeHeight; ty++) {
                    const y = height + ty;
                    if (y < WORLD_HEIGHT) {
                        chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = BLOCKS.WOOD;
                    }
                }
                
                // Leaves
                const leafStart = height + treeHeight - 2;
                for (let dy = 0; dy <= 3; dy++) {
                    const radius = dy < 2 ? 2 : 1;
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dz = -radius; dz <= radius; dz++) {
                            if (dx === 0 && dz === 0 && dy < 2) continue;
                            if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                            const ly = leafStart + dy;
                            const llx = lx + dx, llz = lz + dz;
                            if (llx >= 0 && llx < CHUNK_SIZE && llz >= 0 && llz < CHUNK_SIZE && ly < WORLD_HEIGHT) {
                                const idx = llx + llz * CHUNK_SIZE + ly * CHUNK_SIZE * CHUNK_SIZE;
                                if (chunk[idx] === BLOCKS.AIR) {
                                    chunk[idx] = BLOCKS.LEAVES;
                                }
                            }
                        }
                    }
                }
            }
            
            chunks.set(key, chunk);
        }

        function buildChunkMesh(cx, cz) {
            const key = getChunkKey(cx, cz);
            const chunk = chunks.get(key);
            if (!chunk) return null;
            
            const positions = [], colors = [], normals = [];
            
            const faces = [
                { dir: [1, 0, 0], corners: [[1,0,0],[1,1,0],[1,1,1],[1,0,0],[1,1,1],[1,0,1]], face: 'side' },
                { dir: [-1, 0, 0], corners: [[0,0,1],[0,1,1],[0,1,0],[0,0,1],[0,1,0],[0,0,0]], face: 'side' },
                { dir: [0, 1, 0], corners: [[0,1,0],[0,1,1],[1,1,1],[0,1,0],[1,1,1],[1,1,0]], face: 'top' },
                { dir: [0, -1, 0], corners: [[0,0,1],[0,0,0],[1,0,0],[0,0,1],[1,0,0],[1,0,1]], face: 'bottom' },
                { dir: [0, 0, 1], corners: [[0,0,1],[1,0,1],[1,1,1],[0,0,1],[1,1,1],[0,1,1]], face: 'side' },
                { dir: [0, 0, -1], corners: [[1,0,0],[0,0,0],[0,1,0],[1,0,0],[0,1,0],[1,1,0]], face: 'side' }
            ];
            
            for (let lx = 0; lx < CHUNK_SIZE; lx++) {
                for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                    for (let y = 0; y < WORLD_HEIGHT; y++) {
                        const idx = lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE;
                        const block = chunk[idx];
                        if (block === BLOCKS.AIR) continue;
                        
                        const wx = cx * CHUNK_SIZE + lx;
                        const wz = cz * CHUNK_SIZE + lz;
                        
                        for (const face of faces) {
                            const nx = wx + face.dir[0];
                            const ny = y + face.dir[1];
                            const nz = wz + face.dir[2];
                            const neighbor = getBlock(nx, ny, nz);
                            
                            if (neighbor === BLOCKS.AIR || (neighbor === BLOCKS.WATER && block !== BLOCKS.WATER)) {
                                const color = BLOCK_COLORS[block][face.face];
                                for (const c of face.corners) {
                                    positions.push(wx + c[0], y + c[1], wz + c[2]);
                                    colors.push(color[0], color[1], color[2]);
                                    normals.push(face.dir[0], face.dir[1], face.dir[2]);
                                }
                            }
                        }
                    }
                }
            }
            
            if (positions.length === 0) return null;
            
            const mesh = {
                posBuffer: gl.createBuffer(),
                colorBuffer: gl.createBuffer(),
                normalBuffer: gl.createBuffer(),
                vertexCount: positions.length / 3
            };
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            return mesh;
        }

        function rebuildChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            const oldMesh = chunkMeshes.get(key);
            if (oldMesh) {
                gl.deleteBuffer(oldMesh.posBuffer);
                gl.deleteBuffer(oldMesh.colorBuffer);
                gl.deleteBuffer(oldMesh.normalBuffer);
            }
            const newMesh = buildChunkMesh(cx, cz);
            if (newMesh) chunkMeshes.set(key, newMesh);
            else chunkMeshes.delete(key);
        }

        // === PLAYER ===
        const player = {
            pos: [0, 50, 0],
            vel: [0, 0, 0],
            yaw: 0,
            pitch: 0,
            onGround: false,
            selectedBlock: 0
        };

        const keys = {};
        let isLocked = false;

        // === INPUT HANDLING ===
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code >= 'Digit1' && e.code <= 'Digit7') {
                const idx = parseInt(e.code.charAt(5)) - 1;
                player.selectedBlock = idx;
                updateHotbar();
            }
        });

        document.addEventListener('keyup', e => { keys[e.code] = false; });

        canvas.addEventListener('wheel', e => {
            if (!isLocked) return;
            player.selectedBlock += Math.sign(e.deltaY);
            if (player.selectedBlock < 0) player.selectedBlock = HOTBAR_BLOCKS.length - 1;
            if (player.selectedBlock >= HOTBAR_BLOCKS.length) player.selectedBlock = 0;
            updateHotbar();
            e.preventDefault();
        }, { passive: false });

        // === POINTER LOCK ===
        function requestLock() {
            canvas.requestPointerLock();
        }

        startBtn.addEventListener('click', requestLock);
        blocker.addEventListener('click', e => {
            if (e.target === blocker) requestLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === canvas;
            blocker.classList.toggle('hidden', isLocked);
        });

        document.addEventListener('mousemove', e => {
            if (!isLocked) return;
            player.yaw -= e.movementX * 0.002;
            player.pitch -= e.movementY * 0.002;
            player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
        });

        canvas.addEventListener('mousedown', e => {
            if (!isLocked) return;
            const hit = raycast(5);
            if (hit) {
                if (e.button === 0) {
                    // Break block
                    setBlock(hit.x, hit.y, hit.z, BLOCKS.AIR);
                } else if (e.button === 2) {
                    // Place block
                    const px = hit.x + hit.normal[0];
                    const py = hit.y + hit.normal[1];
                    const pz = hit.z + hit.normal[2];
                    if (!playerIntersectsBlock(px, py, pz)) {
                        setBlock(px, py, pz, HOTBAR_BLOCKS[player.selectedBlock]);
                    }
                }
            }
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        function playerIntersectsBlock(bx, by, bz) {
            const px = player.pos[0], py = player.pos[1], pz = player.pos[2];
            return px + PLAYER_WIDTH > bx && px - PLAYER_WIDTH < bx + 1 &&
                   py + PLAYER_HEIGHT > by && py < by + 1 &&
                   pz + PLAYER_WIDTH > bz && pz - PLAYER_WIDTH < bz + 1;
        }

        function raycast(maxDist) {
            const dir = [
                Math.cos(player.pitch) * Math.sin(player.yaw),
                Math.sin(player.pitch),
                Math.cos(player.pitch) * Math.cos(player.yaw)
            ];
            const eye = [player.pos[0], player.pos[1] + EYE_HEIGHT, player.pos[2]];
            
            let x = Math.floor(eye[0]), y = Math.floor(eye[1]), z = Math.floor(eye[2]);
            const stepX = dir[0] >= 0 ? 1 : -1;
            const stepY = dir[1] >= 0 ? 1 : -1;
            const stepZ = dir[2] >= 0 ? 1 : -1;
            
            const tDeltaX = dir[0] === 0 ? 1e10 : Math.abs(1 / dir[0]);
            const tDeltaY = dir[1] === 0 ? 1e10 : Math.abs(1 / dir[1]);
            const tDeltaZ = dir[2] === 0 ? 1e10 : Math.abs(1 / dir[2]);
            
            let tMaxX = dir[0] === 0 ? 1e10 : ((stepX > 0 ? (x + 1 - eye[0]) : (eye[0] - x)) * tDeltaX);
            let tMaxY = dir[1] === 0 ? 1e10 : ((stepY > 0 ? (y + 1 - eye[1]) : (eye[1] - y)) * tDeltaY);
            let tMaxZ = dir[2] === 0 ? 1e10 : ((stepZ > 0 ? (z + 1 - eye[2]) : (eye[2] - z)) * tDeltaZ);
            
            let face = 0;
            
            for (let i = 0; i < maxDist * 10; i++) {
                const block = getBlock(x, y, z);
                if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                    let normal = [0, 0, 0];
                    if (face === 0) normal[0] = -stepX;
                    else if (face === 1) normal[1] = -stepY;
                    else normal[2] = -stepZ;
                    return { x, y, z, normal, block };
                }
                
                if (tMaxX < tMaxY) {
                    if (tMaxX < tMaxZ) {
                        if (tMaxX > maxDist) break;
                        x += stepX;
                        tMaxX += tDeltaX;
                        face = 0;
                    } else {
                        if (tMaxZ > maxDist) break;
                        z += stepZ;
                        tMaxZ += tDeltaZ;
                        face = 2;
                    }
                } else {
                    if (tMaxY < tMaxZ) {
                        if (tMaxY > maxDist) break;
                        y += stepY;
                        tMaxY += tDeltaY;
                        face = 1;
                    } else {
                        if (tMaxZ > maxDist) break;
                        z += stepZ;
                        tMaxZ += tDeltaZ;
                        face = 2;
                    }
                }
            }
            return null;
        }

        // === COLLISION ===
        function collide(pos, vel, axis) {
            const size = [PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_WIDTH];
            const min = [pos[0] - size[0], pos[1], pos[2] - size[2]];
            const max = [pos[0] + size[0], pos[1] + size[1], pos[2] + size[2]];
            
            const minX = Math.floor(min[0]), maxX = Math.floor(max[0]);
            const minY = Math.floor(min[1]), maxY = Math.floor(max[1]);
            const minZ = Math.floor(min[2]), maxZ = Math.floor(max[2]);
            
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const block = getBlock(x, y, z);
                        if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                            // AABB collision
                            if (max[0] > x && min[0] < x + 1 &&
                                max[1] > y && min[1] < y + 1 &&
                                max[2] > z && min[2] < z + 1) {
                                
                                if (axis === 0) {
                                    if (vel[0] > 0) pos[0] = x - size[0] - 0.001;
                                    else pos[0] = x + 1 + size[0] + 0.001;
                                    vel[0] = 0;
                                } else if (axis === 1) {
                                    if (vel[1] > 0) pos[1] = y - size[1] - 0.001;
                                    else {
                                        pos[1] = y + 1;
                                        player.onGround = true;
                                    }
                                    vel[1] = 0;
                                } else {
                                    if (vel[2] > 0) pos[2] = z - size[2] - 0.001;
                                    else pos[2] = z + 1 + size[2] + 0.001;
                                    vel[2] = 0;
                                }
                            }
                        }
                    }
                }
            }
        }

        function updatePlayer(dt) {
            if (!isLocked) return;
            
            const forward = [Math.sin(player.yaw), 0, Math.cos(player.yaw)];
            const right = [Math.cos(player.yaw), 0, -Math.sin(player.yaw)];
            
            let moveX = 0, moveZ = 0;
            if (keys['KeyW']) { moveX += forward[0]; moveZ += forward[2]; }
            if (keys['KeyS']) { moveX -= forward[0]; moveZ -= forward[2]; }
            if (keys['KeyA']) { moveX -= right[0]; moveZ -= right[2]; }
            if (keys['KeyD']) { moveX += right[0]; moveZ += right[2]; }
            
            const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (len > 0) { moveX /= len; moveZ /= len; }
            
            const speed = keys['ShiftLeft'] ? SPRINT_SPEED : PLAYER_SPEED;
            player.vel[0] = moveX * speed;
            player.vel[2] = moveZ * speed;
            
            // Jump
            if (keys['Space'] && player.onGround) {
                player.vel[1] = JUMP_FORCE;
                player.onGround = false;
            }
            
            // Gravity
            player.vel[1] -= GRAVITY * dt;
            player.vel[1] = Math.max(player.vel[1], -50); // Terminal velocity
            
            // Move and collide for each axis
            player.onGround = false;
            
            player.pos[0] += player.vel[0] * dt;
            collide(player.pos, player.vel, 0);
            
            player.pos[1] += player.vel[1] * dt;
            collide(player.pos, player.vel, 1);
            
            player.pos[2] += player.vel[2] * dt;
            collide(player.pos, player.vel, 2);
            
            // Respawn if fell through world
            if (player.pos[1] < -20) {
                player.pos = [0, 50, 0];
                player.vel = [0, 0, 0];
            }
        }

        // === RENDERING ===
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        const projMatrix = mat4.create();
        const viewMatrix = mat4.create();
        const mvpMatrix = mat4.create();
        const tempMatrix = mat4.create();
        const eye = vec3.create();
        const center = vec3.create();
        const up = vec3.set(vec3.create(), 0, 1, 0);

        function render() {
            gl.clearColor(0.53, 0.81, 0.92, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            mat4.perspective(projMatrix, Math.PI / 2.5, canvas.width / canvas.height, 0.1, 1000);
            
            vec3.set(eye, player.pos[0], player.pos[1] + EYE_HEIGHT, player.pos[2]);
            vec3.set(center,
                eye[0] + Math.cos(player.pitch) * Math.sin(player.yaw),
                eye[1] + Math.sin(player.pitch),
                eye[2] + Math.cos(player.pitch) * Math.cos(player.yaw)
            );
            mat4.lookAt(viewMatrix, eye, center, up);
            mat4.multiply(mvpMatrix, projMatrix, viewMatrix);
            
            gl.useProgram(program);
            gl.uniformMatrix4fv(uMVP, false, mvpMatrix);
            gl.uniform3f(uFogColor, 0.53, 0.81, 0.92);
            gl.uniform1f(uFogNear, RENDER_DISTANCE * CHUNK_SIZE * 0.6);
            gl.uniform1f(uFogFar, RENDER_DISTANCE * CHUNK_SIZE * 1.2);
            gl.uniform3f(uCamPos, eye[0], eye[1], eye[2]);
            
            for (const [key, mesh] of chunkMeshes) {
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.posBuffer);
                gl.enableVertexAttribArray(aPos);
                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
                gl.enableVertexAttribArray(aColor);
                gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                gl.enableVertexAttribArray(aNormal);
                gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLES, 0, mesh.vertexCount);
            }
            
            // Render block outline
            const hit = raycast(5);
            if (hit) {
                renderBlockOutline(hit.x, hit.y, hit.z);
            }
        }

        function renderBlockOutline(x, y, z) {
            // Slightly offset to prevent z-fighting
            const offset = 0.005;
            
            mat4.identity(tempMatrix);
            tempMatrix[12] = x - offset;
            tempMatrix[13] = y - offset;
            tempMatrix[14] = z - offset;
            const scale = 1 + offset * 2;
            tempMatrix[0] = scale;
            tempMatrix[5] = scale;
            tempMatrix[10] = scale;
            
            const outlineMVP = mat4.create();
            mat4.multiply(outlineMVP, mvpMatrix, tempMatrix);
            
            gl.useProgram(outlineProgram);
            gl.uniformMatrix4fv(outlineUMVP, false, outlineMVP);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, outlineBuffer);
            gl.enableVertexAttribArray(outlineAPos);
            gl.vertexAttribPointer(outlineAPos, 3, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.LINES, 0, 24);
        }

        // === HOTBAR ===
        function createHotbar() {
            hotbarEl.innerHTML = '';
            HOTBAR_BLOCKS.forEach((block, i) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === player.selectedBlock ? ' selected' : '');
                
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                const color = BLOCK_COLORS[block].top;
                preview.style.background = `rgb(${Math.floor(color[0]*255)},${Math.floor(color[1]*255)},${Math.floor(color[2]*255)})`;
                preview.style.boxShadow = 'inset -4px -4px 8px rgba(0,0,0,0.4), inset 4px 4px 8px rgba(255,255,255,0.2)';
                preview.title = BLOCK_NAMES[block];
                
                slot.appendChild(preview);
                hotbarEl.appendChild(slot);
            });
        }

        function updateHotbar() {
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                slot.classList.toggle('selected', i === player.selectedBlock);
            });
        }

        createHotbar();

        // === CHUNK MANAGEMENT ===
        function updateChunks() {
            const pcx = Math.floor(player.pos[0] / CHUNK_SIZE);
            const pcz = Math.floor(player.pos[2] / CHUNK_SIZE);
            
            // Generate nearby chunks
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                    const cx = pcx + dx, cz = pcz + dz;
                    const key = getChunkKey(cx, cz);
                    if (!chunks.has(key)) {
                        generateChunk(cx, cz);
                    }
                    if (!chunkMeshes.has(key) && chunks.has(key)) {
                        const mesh = buildChunkMesh(cx, cz);
                        if (mesh) chunkMeshes.set(key, mesh);
                    }
                }
            }
            
            // Remove far chunks
            const removeDistance = RENDER_DISTANCE + 2;
            for (const [key, mesh] of chunkMeshes) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - pcx) > removeDistance || Math.abs(cz - pcz) > removeDistance) {
                    gl.deleteBuffer(mesh.posBuffer);
                    gl.deleteBuffer(mesh.colorBuffer);
                    gl.deleteBuffer(mesh.normalBuffer);
                    chunkMeshes.delete(key);
                    chunks.delete(key);
                }
            }
        }

        // === SPAWN POINT ===
        function findSpawnPoint() {
            // Generate initial chunks first
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    generateChunk(dx, dz);
                }
            }
            
            // Find ground level at spawn
            for (let y = WORLD_HEIGHT - 1; y >= 0; y--) {
                const block = getBlock(0, y, 0);
                if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                    player.pos[1] = y + 2;
                    break;
                }
            }
        }

        // === MAIN LOOP ===
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;
        let fps = 0;

        function gameLoop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                fps = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }
            
            updatePlayer(dt);
            updateChunks();
            render();
            
            const blockName = BLOCK_NAMES[HOTBAR_BLOCKS[player.selectedBlock]];
            debugEl.innerHTML = `FPS: ${fps}<br>` +
                `XYZ: ${player.pos[0].toFixed(1)}, ${player.pos[1].toFixed(1)}, ${player.pos[2].toFixed(1)}<br>` +
                `Chunks: ${chunkMeshes.size}<br>` +
                `Block: ${blockName}`;
            
            requestAnimationFrame(gameLoop);
        }

        // === START GAME ===
        findSpawnPoint();
        updateChunks();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>