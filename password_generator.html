<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Password Generator</title>
  <style>
    :root {
      --bg: #0b0c10;
      --card: #11131a;
      --fg: #e6e6e6;
      --muted: #9aa3af;
      --primary: #4f46e5;
      --primary-600: #4338ca;
      --accent: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --border: #1f2430;
      --focus: #93c5fd;
      --shadow: 0 6px 28px rgba(0,0,0,0.35);
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f7fafc;
        --card: #ffffff;
        --fg: #0f172a;
        --muted: #475569;
        --primary: #4f46e5;
        --primary-600: #4338ca;
        --accent: #16a34a;
        --warn: #b45309;
        --danger: #dc2626;
        --border: #e5e7eb;
        --shadow: 0 6px 28px rgba(0,0,0,0.07);
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #13172a 0%, var(--bg) 45%) no-repeat fixed;
      color: var(--fg);
    }

    .container {
      max-width: 840px;
      margin: 48px auto;
      padding: 0 16px;
    }

    .card {
      background: linear-gradient(180deg, color-mix(in oklab, var(--card) 92%, transparent) 0%, var(--card) 100%);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 22px;
    }

    h1 {
      font-size: 28px;
      margin: 0 0 16px 0;
      letter-spacing: 0.2px;
    }
    .subtle { color: var(--muted); font-size: 14px; margin-top: 4px; }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }
    @media (min-width: 720px) {
      .grid {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    .field { margin: 8px 0; }

    label { display: inline-flex; align-items: center; gap: 10px; user-select: none; }
    input[type="checkbox"] { width: 18px; height: 18px; }
    input[type="number"], input[type="text"] {
      width: 100%;
      padding: 12px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--card) 92%, #000 0%);
      color: var(--fg);
      outline: none;
    }
    input[type="number"]:focus, input[type="text"]:focus {
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--focus) 35%, transparent);
      border-color: color-mix(in oklab, var(--focus) 35%, var(--border));
    }
    input[type="range"] {
      width: 100%;
      accent-color: var(--primary);
      cursor: pointer;
    }

    .btn {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 12px 14px;
      font-weight: 600;
      cursor: pointer;
      color: white;
      background: linear-gradient(180deg, color-mix(in oklab, var(--primary) 86%, transparent), var(--primary-600));
      box-shadow: 0 8px 18px rgba(79,70,229,0.28);
    }
    .btn.secondary {
      color: var(--fg);
      background: transparent;
      border: 1px solid var(--border);
      box-shadow: none;
    }
    .btn:active { transform: translateY(1px); }

    .output {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 10px;
      align-items: center;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.3px;
    }

    .meter-wrap {
      margin-top: 8px;
    }
    .meter-bar {
      height: 10px;
      width: 100%;
      background: color-mix(in oklab, var(--border) 70%, transparent);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .meter-fill {
      height: 100%;
      width: 0%;
      background: var(--danger);
      transition: width 220ms ease, background 220ms ease;
    }
    .meter-row {
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
      color: var(--muted);
      font-size: 14px;
    }

    .options {
      display: grid;
      gap: 10px;
    }
    .opts-rows {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 16px;
    }
    @media (max-width: 460px) {
      .output { grid-template-columns: 1fr; }
      .opts-rows { grid-template-columns: 1fr; }
    }

    .status {
      min-height: 20px;
      font-size: 14px;
      color: var(--muted);
      margin-top: 8px;
    }
    .status.ok { color: var(--accent); }
    .status.warn { color: var(--warn); }
    .status.err { color: var(--danger); }

    .kbd {
      padding: 0 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--card) 92%, transparent);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Password Generator</h1>
    <div class="subtle">Strong, random passwords generated in your browser using the Web Crypto API (no network or dependencies).</div>

    <div class="card grid" role="region" aria-label="Password generator">
      <div>
        <div class="field">
          <div class="row">
            <label for="lenRange">Length</label>
            <input id="lenNumber" type="number" min="4" max="128" value="16" aria-label="Password length (number)">
          </div>
          <input id="lenRange" type="range" min="4" max="128" value="16" aria-label="Password length (slider)">
        </div>

        <div class="options">
          <div class="opts-rows" role="group" aria-label="Character sets">
            <label><input type="checkbox" id="optLower" checked> a-z (lowercase)</label>
            <label><input type="checkbox" id="optUpper" checked> A-Z (uppercase)</label>
            <label><input type="checkbox" id="optNums" checked> 0-9 (numbers)</label>
            <label><input type="checkbox" id="optSyms" checked> Symbols <span class="kbd">!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</span></label>
          </div>
          <label><input type="checkbox" id="optNoAmbig"> Exclude similar-looking characters (e.g., 0/O, 1/l/I, 5/S, 2/Z, 6/G, 8/B)</label>
        </div>

        <div class="status" id="status" role="status" aria-live="polite"></div>

        <div class="field" style="display:flex; gap:10px; margin-top:10px;">
          <button class="btn" id="btnGen">Generate password</button>
          <button class="btn secondary" id="btnCopy" title="Copy to clipboard">Copy</button>
        </div>
      </div>

      <div>
        <div class="field output" aria-live="off">
          <input id="output" class="mono" type="text" readonly value="" aria-label="Generated password">
          <button class="btn secondary" id="btnShow" aria-pressed="false" title="Toggle visibility">Show</button>
          <button class="btn secondary" id="btnRegen" title="Regenerate">↻</button>
        </div>

        <div class="meter-wrap" aria-hidden="false">
          <div class="meter-bar" aria-hidden="true"><div id="meterFill" class="meter-fill"></div></div>
          <div class="meter-row">
            <div id="strengthLabel">Strength: —</div>
            <div id="entropyLabel" class="mono">Entropy: —</div>
          </div>
        </div>
      </div>
    </div>

    <div class="subtle" style="margin-top:12px;">
      Tip: Store generated passwords in a reputable password manager. Press <span class="kbd">Tab</span> then <span class="kbd">Enter</span> to quickly generate again.
    </div>
  </div>

  <script>
    // Character sets
    const SETS = {
      lower: 'abcdefghijklmnopqrstuvwxyz',
      upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      nums:  '0123456789',
      syms:  '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
    };
    // Characters commonly considered ambiguous/similar-looking
    const AMBIGUOUS = new Set('il1Lo0O|I5S2Z8B6G9');

    // DOM elements
    const lenRange = document.getElementById('lenRange');
    const lenNumber = document.getElementById('lenNumber');
    const optLower = document.getElementById('optLower');
    const optUpper = document.getElementById('optUpper');
    const optNums  = document.getElementById('optNums');
    const optSyms  = document.getElementById('optSyms');
    const optNoAmbig = document.getElementById('optNoAmbig');

    const btnGen  = document.getElementById('btnGen');
    const btnCopy = document.getElementById('btnCopy');
    const btnShow = document.getElementById('btnShow');
    const btnRegen= document.getElementById('btnRegen');

    const outInput = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const meterFill = document.getElementById('meterFill');
    const strengthLabel = document.getElementById('strengthLabel');
    const entropyLabel  = document.getElementById('entropyLabel');

    // Utility: secure random int in [0, max)
    function randInt(maxExclusive) {
      if (!Number.isInteger(maxExclusive) || maxExclusive <= 0) {
        throw new Error('randInt: maxExclusive must be a positive integer');
      }
      const maxUint = 0xFFFFFFFF;
      const limit = Math.floor((maxUint + 1) / maxExclusive) * maxExclusive;
      const buf = new Uint32Array(1);
      let r;
      do {
        crypto.getRandomValues(buf);
        r = buf[0];
      } while (r >= limit);
      return r % maxExclusive;
    }

    // Secure in-place Fisher–Yates shuffle
    function secureShuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = randInt(i + 1);
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function getSettings() {
      const length = clamp(parseInt(lenNumber.value, 10) || 16, 4, 128);
      const noAmbig = !!optNoAmbig.checked;

      const sets = [];
      const selected = {
        lower: !!optLower.checked,
        upper: !!optUpper.checked,
        nums:  !!optNums.checked,
        syms:  !!optSyms.checked,
      };

      const pools = {};
      for (const key of Object.keys(selected)) {
        if (!selected[key]) continue;
        const chars = Array.from(SETS[key]).filter(ch => !noAmbig || !AMBIGUOUS.has(ch));
        if (chars.length > 0) {
          pools[key] = chars;
          sets.push(chars);
        }
      }

      const pool = Array.from(new Set(sets.flat())); // union (avoid duplicates, minor bias safeguards)
      return {
        length,
        selected,
        noAmbig,
        pools,
        pool,
        groupsCount: sets.length
      };
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function generateOnce() {
      const s = getSettings();
      // Validate selection
      if (s.pool.length === 0) {
        setStatus('Select at least one character type.', 'err');
        outInput.value = '';
        updateStrength('');
        return '';
      }

      // Assemble password ensuring at least one char from each selected group when possible
      const requiredChars = [];
      for (const [k, arr] of Object.entries(s.pools)) {
        if (Array.isArray(arr) && arr.length > 0) {
          requiredChars.push(arr[randInt(arr.length)]);
        }
      }

      const needGuarantee = s.length >= requiredChars.length;
      if (!needGuarantee && requiredChars.length > 0) {
        setStatus(`Length is shorter than selected groups (${s.length} < ${requiredChars.length}). Some groups may be missing.`, 'warn');
      } else {
        clearStatus();
      }

      const result = [];
      if (needGuarantee) {
        result.push(...requiredChars);
      }

      const remaining = s.length - result.length;
      for (let i = 0; i < remaining; i++) {
        result.push(s.pool[randInt(s.pool.length)]);
      }

      secureShuffle(result);
      const pwd = result.join('');
      outInput.value = pwd;
      updateStrength(pwd, s.pool.length);
      return pwd;
    }

    function estimateEntropyBits(length, poolSize) {
      if (!length || !poolSize) return 0;
      return length * Math.log2(poolSize);
    }

    function updateStrength(pwd, poolSizeGuess) {
      const length = pwd.length;
      let poolSize = poolSizeGuess;
      if (!poolSize) {
        // Fallback rough estimate from observed character classes
        const classes = {
          lower: /[a-z]/.test(pwd),
          upper: /[A-Z]/.test(pwd),
          nums:  /[0-9]/.test(pwd),
          syms:  /[^A-Za-z0-9]/.test(pwd)
        };
        poolSize = 0;
        if (classes.lower) poolSize += 26;
        if (classes.upper) poolSize += 26;
        if (classes.nums)  poolSize += 10;
        if (classes.syms)  poolSize += 32; // approximate
      }
      const bits = estimateEntropyBits(length, poolSize);
      const pct = Math.max(0, Math.min(100, Math.round((bits / 128) * 100))); // 128 bits ~ excellent

      entropyLabel.textContent = length ? `Entropy: ${bits.toFixed(1)} bits` : 'Entropy: —';
      // Map to label and color
      let label = 'Very weak', color = 'var(--danger)';
      if (bits >= 128) { label = 'Excellent'; color = 'var(--accent)'; }
      else if (bits >= 80) { label = 'Strong'; color = 'var(--accent)'; }
      else if (bits >= 60) { label = 'Good'; color = 'var(--warn)'; }
      else if (bits >= 40) { label = 'Fair'; color = 'var(--warn)'; }
      else { label = 'Weak'; color = 'var(--danger)'; }

      strengthLabel.textContent = `Strength: ${label}`;
      meterFill.style.width = `${pct}%`;
      meterFill.style.background = color;
    }

    function setStatus(msg, kind='ok') {
      statusEl.textContent = msg;
      statusEl.classList.remove('ok','warn','err');
      statusEl.classList.add(kind);
    }
    function clearStatus() {
      statusEl.textContent = '';
      statusEl.classList.remove('ok','warn','err');
    }

    async function copyToClipboard(text) {
      try {
        if (!text) { setStatus('Nothing to copy.', 'warn'); return; }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          // Fallback
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.setAttribute('readonly', '');
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        setStatus('Copied to clipboard.', 'ok');
      } catch {
        setStatus('Failed to copy. You can select and copy manually.', 'warn');
      }
    }

    // Sync length controls
    function syncFromRange() {
      lenNumber.value = lenRange.value;
      generatePreview();
    }
    function syncFromNumber() {
      const v = clamp(parseInt(lenNumber.value, 10) || 16, parseInt(lenNumber.min,10), parseInt(lenNumber.max,10));
      lenNumber.value = v;
      lenRange.value = String(v);
      generatePreview();
    }

    function generatePreview() {
      // Only update meter/entropy; do not overwrite password if one exists unless empty
      if (outInput.value) {
        const s = getSettings();
        updateStrength(outInput.value, s.pool.length);
      } else {
        const s = getSettings();
        updateStrength('x'.repeat(s.length), s.pool.length); // indicative meter for current settings
      }
    }

    // Event listeners
    lenRange.addEventListener('input', syncFromRange);
    lenNumber.addEventListener('input', syncFromNumber);

    for (const el of [optLower, optUpper, optNums, optSyms, optNoAmbig]) {
      el.addEventListener('change', () => {
        clearStatus();
        generatePreview();
      });
    }

    btnGen.addEventListener('click', (e) => {
      e.preventDefault();
      generateOnce();
      outInput.focus();
      outInput.select();
    });

    btnRegen.addEventListener('click', (e) => {
      e.preventDefault();
      generateOnce();
      outInput.focus();
      outInput.select();
    });

    btnCopy.addEventListener('click', (e) => {
      e.preventDefault();
      copyToClipboard(outInput.value);
    });

    btnShow.addEventListener('click', (e) => {
      e.preventDefault();
      const pressed = btnShow.getAttribute('aria-pressed') === 'true';
      btnShow.setAttribute('aria-pressed', String(!pressed));
      btnShow.textContent = pressed ? 'Show' : 'Hide';
      outInput.setAttribute('type', pressed ? 'text' : 'text'); // remains text to allow selection; we just toggle masking via font
      // Alternate option: use password type. But we keep text for easy copying; mask by CSS if desired.
    });

    // Keyboard shortcuts: Enter to generate when focused in length/checkboxes; Ctrl/Cmd+C to copy when output focused
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (document.activeElement === lenNumber || document.activeElement === lenRange)) {
        e.preventDefault();
        generateOnce();
      }
    });

    // Initial render
    (function init() {
      generateOnce();
      // Reselect text for quick copy
      outInput.select();
    })();
  </script>
</body>
</html>